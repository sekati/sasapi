/** * com.sekati.log.Logger * @version 1.0.0 * @author jason m horwitz | sekati.com | tendercreative.com * Copyright (C) 2007  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package com.sekati.log {	import com.sekati.time.StopWatch;	import flash.events.EventDispatcher;	import flash.utils.getQualifiedClassName;	/**	 * Logger - central logging class for SASAPI.	 */	dynamic public class Logger extends EventDispatcher {		public static var _instance:Logger;		private var _levels:Object;		private var _filters:Array;		private var _logId:int;		private var _watch:StopWatch;		private var _isEnabled:Boolean;		// level stubs		public var trace:Function;		public var info:Function;		public var status:Function;		public var notice:Function;			public var warn:Function;		public var error:Function;		public var fatal:Function;		/**		 * Logger Singleton Constructor		 * @param $ SingletonEnforcer - internal to the AS file; the param prevents external instantiation without error.		 */		public function Logger( $:SingletonEnforcer ) {			_watch = new StopWatch( true );			_logId = 0;			_isEnabled = true;			resetLevels( );			resetFilters( );			}		/**		 * Singleton Accessor		 * @return Logger		 */		public static function getInstance():Logger {			if( _instance == null ) _instance = new Logger( new SingletonEnforcer( ) );			return _instance;		}		/**		 * Shorthand singleton accessor getter		 * @return Logger		 */		public static function get $():Logger {			return Logger.getInstance( );			}		// CORE CONTROLLERS				/**		 * enabled setter		 * @param b (Boolean) enable or disable Logger		 */		public function set enabled(b:Boolean):void {			_isEnabled = b;		}		/**		 * enabled getter		 * @return Boolean		 */			public function get enabled():Boolean {			return _isEnabled;		}		/**		 * level and filter _status getter		 * @return String		 */		public function get _status():String {			return getLevels( ) + "\n" + getFilters( );		}		/**		 * reset Out to default levels and filters		 * @return void		 */		public function reset():void {			setAllLevels( true );			resetFilters( );		}				// LEVEL HANDLERS				/**		 * Enable/disable a level and create the level if it does not already exist.		 * @param level (String) level name		 * @param isEnabled (Boolean) enabled status		 * @return void		 */		public function setLevel(level:String, isEnabled:Boolean):void {			_levels[level.toLowerCase( )] = isEnabled;		}		/**		 * Enable or disable all existing levels.		 * @param isEnabled (Boolean) enabled status		 * @return void		 */		public function setAllLevels(isEnabled:Boolean):void {			for (var i:String in _levels) {				setLevel( _levels[i], isEnabled );			}		}		/**		 * Reset all levels (clearing previously created levels)		 * @return void		 */		public function resetLevels():void {			_levels = {trace:true, info:true, status:true, notice:true, warn:true, error:true, fatal:true, object:true};		}		/**		 * Returns a stringified overview of all levels statuses.		 * @return String		 */		public function getLevels():String {			var a:Array = new Array( );			for (var i:String in _levels) {				a.push( i + ":" + _levels[i].toString( ) );			}			return "_levels={" + a.toString( ) + "};";		}					// FILTER HANDLERS			/**		 * Enable/disable a filter and create the filter if it does not already exist.		 * @param origin (Object) object to filter on [usually a string]		 * @param isFiltered (Boolean)		 * @return void		 */		public function setFilter(origin:Object, isFiltered:Boolean):void {			if (isFiltered) {				filter( origin );			} else {				unfilter( origin );			}		}		/**		 * Returns a stringified overview of all filters statuses.		 * @return String		 */		public function getFilters():String {			return "_filters=[" + _filters.toString( ) + "];";		}		/**		 * Reset all filters (clearing previous filters)		 * @return void		 */		public function resetFilters():void {			_filters = [];		}		/**		 * Check if an origin's output is being filtered		 * @param origin (Object) to check.		 * @return Boolean		 */		public function isFiltered(origin:Object):Boolean {			var o:String = String( origin );			for (var i:Number = 0; i < _filters.length ; i++) {				if (_filters[i] == o) {					return true;				}			}			return false;		}			/**		 * Add an origin to the filters array.		 * @param origin (Object) to be added.		 * @return void		 */		private function filter(origin:Object):void {			var o:String = String( origin );			if (!isFiltered( o )) {				_filters.push( o );			}		}		/**		 * Remove an origin from the filters array.		 * @param origin (Object) to be removed.		 * @return void		 */		private function unfilter(origin:Object):void {			var o:String = String( origin );			for (var i:Number = 0; i < _filters.length ; i++) {				if (_filters[i] == o) {					_filters.splice( i, 1 );					break;				}			}		}	}}/** * Internal class is accessible only to this AS file * and is used as a constructor param to enforce * proper Singleton behavior. */internal class SingletonEnforcer {}