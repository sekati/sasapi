/** * com.sekati.ui.Scroll * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package com.sekati.ui {	import flash.display.*;	import flash.events.*;	import flash.geom.Rectangle;	import com.sekati.external.MouseWheel;	import com.sekati.reflect.ClassReflector;	import com.sekati.validate.OSValidation;	import caurina.transitions.Tweener;	/**	 * Scroll handles mouseWheel (PC & Mac), dynamic resizing of content, external size tracking for accordian 	 * style content scrolling, slideContent method, modal ui states, proportional bar, gutter and more.	 */	final public class Scroll extends Sprite {		private const EASE_EQUATION:String = "easeOutQuad";		// scroll properties		private var _axis:String;		private var _prop:String; 		// scroll objects		private var _this:Scroll;		private var _content:Sprite;		private var _mask:Sprite;			private var _gutter:Sprite;		private var _bar:Sprite;		private var _contentSizeTracker:Sprite;		// options		private var _isResizeGutter:Boolean;		private var _isResizeBar:Boolean;		private var _isMouseWheel:Boolean;		private var _friction:Number;		private var _ratio:Number;		// state tracking		private var _isDrag:Boolean;		private var _contentTop:Number;		private var _contentBot:Number;		private var _gutterTop:Number;		private var _gutterBot:Number;		private var _oldPos:Number;		private var _newPos:Number;		private var _speed:Number;		/**		 * Scroll Constructor		 * @param content (Object) content object		 * @param mask (MovieClip) content mask		 * @param gutter (MovieClip) gutter object		 * @param bar (MovieClip) scroller bar object		 * @param contentSizeTracker (Object) optional object used to track content size. Useful in accordian content where visibility or masking is used to hide partial content [default: content]		 * @param axis (String) axis the scroller will scroll on: must be "_x" or "_y"		 * @param isInit (Boolean) optional init scroller upon instantiation, else {@link #init()} must be called manually		 * @param isResizeGutter (Boolean) optional resize gutter to content mask		 * @param isResizeBar (Boolean) optional resize bar proportional to content		 * @param isMouseWheel (Boolean) optional enable mouseWheel scrolling (one may choose to use 2 instances of Scroll for hscroll & vscroll and only want vscroll in which case mouseWheel should only be enabled for one instance)		 * @param friction (Number) optional scroll motion friction [default 0.8] 		 * @param ratio (Number) optional scroll motion ratio [default 0.5]		 * @return void		 * @throws Error if axis is not "x" or "y" & returns without proper instantiation		 * <code>		 * 	var scroll:Scroll = new Scroll( content, mask, gutter, bar, content, "x", true, true, true, true, 0.7, 0.4 );		 * </code>		 */		public function Scroll(content:Sprite, mask:Sprite, gutter:Sprite, bar:Sprite, contentSizeTracker:Sprite, axis:String = "y", isInit:Boolean = true, isResizeGutter:Boolean = true, isResizeBar:Boolean = true, isMouseWheel:Boolean = true, friction:Number = 0.8, ratio:Number = 0.5) {			if (axis != "x" && axis != "y") {				throw new Error( "Scroll Constructor expects axis param: 'x' or 'y'." );			}			// class defined			_this = this;			_speed = 0;					_prop = (axis == "y") ? "height" : "width";			_isDrag = false;						// user defined			_content = content;			_mask = mask;			_gutter = gutter;			_bar = bar;			_contentSizeTracker = contentSizeTracker;			_axis = axis;			_isResizeBar = isResizeBar;			_isResizeGutter = isResizeGutter;			_isMouseWheel = isMouseWheel;			_friction = friction;			_ratio = ratio;			// auto init on request ...			if (isInit) {				init( );			}						trace( ClassReflector.getFullyQualifiedClassName( _this ) + " successfully Instantiated!" );		}		/**		 * Initialize scroll behavior: define confines, mouseWheel, and set scroller to rollout color state.		 * @return void		 */		public function init():void {			setConfines( );			setMouseWheel( );						_bar.buttonMode = true;			_gutter.buttonMode = true;						// events			addEventListener( Event.ENTER_FRAME, onEnterFrame, false, 0, true );			_gutter.addEventListener( MouseEvent.CLICK, gutter_onPress, false, 0, true );			_bar.addEventListener( MouseEvent.MOUSE_DOWN, bar_onPress, false, 0, true );			_bar.addEventListener( MouseEvent.MOUSE_UP, bar_onRelease, false, 0, true );		}		// CONFINE DRIVERS						/**		 * Store the scrollable confines & resize the bar and gutter if necessary.		 */		private function setConfines():void {			_contentTop = _content[_axis];			_gutterTop = _gutter[_axis];			_gutterBot = _gutter[_axis] + _gutter[_prop];			if (!_isResizeBar) {				_gutterBot -= _bar[_prop];			}			// scale gutter to content mask			_gutter[_prop] = (_isResizeGutter) ? _mask[_prop] : _gutter[_prop];			updateConfines( );		}		/**		 * Set content related confines (isloated from setConfines as this may need to be called upon content size changes).		 */		private function updateConfines():void {			_contentBot = _contentTop + _contentSizeTracker[_prop];			//scale scroller bar in proportion to the content to scroll			if (_isResizeBar) {				// new proportioning				var percent:Number = Math.ceil( (_mask[_prop] / _contentSizeTracker[_prop]) * 100 );							_bar[_prop] = _gutter[_prop] * percent / 100;				//get new gutterBot with new size of scrollerbar                               				_gutterBot = _gutter[_axis] + _gutter[_prop] - _bar[_prop];			}		}		/**		 * Insure scroller moves within boundaries.		 */		private function resolveScrollerPos(pos:Number):Number {			return Math.max( Math.min( pos, _gutterBot ), _gutterTop );		}		// SCROLL MOTIONS		/**		 * Tween content to position, scroller will reposition accordingly.		 * @param pos (Number) position to slide content on axis		 * @param sec (Number) optional tween duration in seconds [default: 0.5]		 * @return void		 */		public function slideContent(pos:Number, sec:Number):void {			var newScrollPos:Number = (_contentTop - pos) * (_gutterBot - _gutterTop) / (_gutterBot - _contentBot + _bar[_prop]) + _gutterTop;			slideScroller( newScrollPos, sec );		}		/**		 * Tween bar to position, content will reposition accordingly.		 * @param pos (Number) position to slide scroller on axis		 * @param sec (Number) optional tween duration in seconds [default: 0.3]		 * @return void		 */		public function slideScroller(pos:Number, sec:Number = 0.3):void {			stopScroller( );			updateConfines( );			var base:Object = (_axis == "y") ? { y:resolveScrollerPos( pos ) } : { x:resolveScrollerPos( pos ) };			Tweener.addTween( _bar, {base:base, time:sec, rounded:true, transition:EASE_EQUATION} );		}		/**		 * Move the scroller bar by a certain amount		 * @param amount (Number) pixels to move: positive or negative		 * @return void		 * <code>		 * 	_myScroll.moveScroll( -100 );		 * </code>		 */		public function moveScroller(amount:Number):void {			stopScroller( );			updateConfines( );			_bar.y = resolveScrollerPos( _bar.y + amount );		}			/**		 * Stop all scrolling motions		 */		public function stopScroller():void {			_speed = 0;			Tweener.removeTweens( _bar, _axis );		}				// SCROLLABLE GETTER/SETTERS						/**		 * Check if content is scrollable.		 * @return Boolean		 */		public function get isScrollable():Boolean {			// check if we need a scroller at all			var _isScrollable:Boolean = (_content[_axis] <= _mask[_axis] && _contentSizeTracker[_prop] < _mask[_prop]) ? false : true;			return _isScrollable;		}		/**		 * Check if bar is being dragged.		 * @return Boolean		 */		public function get isDragging():Boolean {			return _isDrag;			}				/**		 * Check if Mouse is in scrollable area.		 * @return Boolean		 */		public function get isMouseInArea():Boolean {			var x:Number = _content.parent.mouseX;			var y:Number = _content.parent.mouseY;			return (x >= 0 && x <= _mask.width && y >= 0 && y <= _mask.height);		}		// SCROLL CORE				/**		 * enter frame runs the core scroll logic.		 */		private function onEnterFrame(e:Event):void {			//trace( "eof" );			_bar.visible = isScrollable;			// height changed, adjust scroller			if (_contentBot != _contentTop + _contentSizeTracker[_prop]) {				_contentBot = _contentTop + _contentSizeTracker[_prop];				updateConfines( );				_bar[_axis] = resolveScrollerPos( (_contentTop + _content[_axis]) * (_gutterBot - _gutterTop) / (_gutterBot - _contentBot + _bar[_prop]) + _gutterTop );			}                                                                                              			if (!_isDrag) {				_oldPos = _bar[_axis];				_newPos = _oldPos + _speed;				if (_newPos > _gutterBot || _newPos < _gutterTop) {					//bounce - reverse movement					_speed = -_speed;					_newPos = _oldPos;				}				_speed = Math.round( _speed * _friction * 100 ) / 100;			} else {				_oldPos = _newPos;				_newPos = _bar[_axis];			}			//update scroller			_bar[_axis] = _newPos;			//update content			var percent:Number = (_bar[_axis] - _gutterTop) / (_gutterBot - _gutterTop);			_content[_axis] = Math.round( (percent * (_gutterBot - _contentBot + _bar[_prop])) + _contentTop );			//weird throw bug fix - gets stuck on speed 0.05 when scroller is thrown upwards and decelerates			if (_speed < 0.1 && _speed > -0.1) {				_speed = 0;			}					}		// UI EVENT HANDLERS		/**		 * bar press - start bar drag: register a pseudo		 * onReleaseOutside event listener on stage.		 */		private function bar_onPress(e:MouseEvent):void {			//trace( "press" );			var bounds:Rectangle;			stopScroller( );			_isDrag = true;			if(_axis == "y") {				bounds = new Rectangle( _bar.x, _gutterTop, 0, _gutterBot );				_bar.startDrag( false, bounds ); 			} else {				bounds = new Rectangle( _gutterTop, _bar.y, _gutterBot, 0 );				_bar.startDrag( false, bounds );			}						// listen for a pseudo "onReleaseOutside": why adobe - why?			_bar.stage.addEventListener( MouseEvent.MOUSE_UP, bar_onRelease, false, 0, true );		}		/**		 * bar release - stop bar drag: unregister a pseudo		 * onReleaseOutside event listener from stage.		 */		private function bar_onRelease(e:MouseEvent):void {			trace( "release" );			_bar.stopDrag( );			_isDrag = false;			//throw			_speed = (_newPos - _oldPos) * _ratio;						// cleanup after our pseudo "onReleaseOutside".			_bar.stage.removeEventListener( MouseEvent.MOUSE_UP, bar_onRelease );				}		/**		 * gutter click		 */		private function gutter_onPress(e:MouseEvent):void {			trace( "gutter click" );			if (isScrollable) {				_gutter.useHandCursor = true;				var mousePos:Number = (_axis == "y") ? _gutter.parent.mouseY : _gutter.parent.mouseX;				slideScroller( mousePos - (_bar[_prop] / 2) );			} else {				_gutter.useHandCursor = false;			}					}		// MOUSE WHEEL				/**		 * mouse wheel		 */		private function onMouseWheel(e:MouseEvent):void {			trace( "mouseWheel" + e.delta );			if (isMouseInArea && isScrollable) {				var m:Number = _bar[_axis] - ((_gutter[_prop] / 5) * (e.delta / 3));				slideScroller( m );			}					}		private function externalMouseWheel(delta:Number):void {			trace( "externalMouseWheel" + delta );			if (isMouseInArea && isScrollable) {				var m:Number = _bar[_axis] - ((_gutter[_prop] / 5) * (delta / 3));				slideScroller( m );			}		}		/**		 * Initialize Mac/PC compatible MouseWheel support		 */		private function setMouseWheel():void {			if (_isMouseWheel) {				trace( "setting up mouse wheel ..." );				//MouseWheel.init( this );				if (!OSValidation.isMac( )) { 					_mask.addEventListener( MouseEvent.MOUSE_WHEEL, onMouseWheel, false, 0, true );				} else {					//_mouseWheel = new MouseWheel( onMouseWheel );					//_mouseWheel:MouseWheel = new MouseWheel( onMouseWheel );					MouseWheel.init( );					MouseWheel.MouseWheelHandler = externalMouseWheel;				}			}		}		// CLEANUP						/**		 * cleanly destroy Scroll instances.		 * @return void;		 */		public function destroy():void {			removeEventListener( Event.ENTER_FRAME, onEnterFrame );			_gutter.removeEventListener( MouseEvent.CLICK, gutter_onPress );			_bar.removeEventListener( MouseEvent.MOUSE_DOWN, bar_onPress );			_bar.removeEventListener( MouseEvent.MOUSE_UP, bar_onRelease );			_bar.stage.removeEventListener( MouseEvent.MOUSE_UP, bar_onRelease );							_mask.removeEventListener( MouseEvent.MOUSE_WHEEL, onMouseWheel );		}			}}