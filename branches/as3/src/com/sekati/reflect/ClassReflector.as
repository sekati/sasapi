/** * com.sekati.reflect.ClassReflector * @version 1.0.0 * @author jason m horwitz | sekati.com | tendercreative.com * Copyright (C) 2007  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */ package com.sekati.reflect {	import flash.utils.describeType;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;	/**	 * ClassReflector provides a centralized static class reflection API for SASAPI.	 * @see http://di-as3.googlecode.com/svn/trunk/core/src/com/anywebcam/reflection/ClassInfo.as	 */	public class ClassReflector {		/**		 * Return the fully qualified class name of the object.		 */		public static function getFullyQualifiedClassName(o:*):String {			return getQualifiedClassName( o );		}		/**		 * Return the class name of the object		 */		public static function getClassName(o:*):String {			var c:String = getFullyQualifiedClassName( o );			var s:String = (c == "String" ? o : c.split( "::" )[1] || c);			return s;					}		/**		 * Return the class name without namespaces.		 */		public static function getClassShortName(o:*):String {			return getFullyQualifiedClassName( o ).split( "::" ).pop( );		}		/**		 * Return the package of the class object.		 */		public static function getPackageName(o:*):String {			return getFullyQualifiedClassName( o ).split( "::" ).shift( );		}		public static function getType(o:*):Class {			var type:Class = (o is Class) ? (o as Class) : getDefinitionByName( getFullyQualifiedClassName( o ) ) as Class;			return type;		}		/**		 * Return the output of describeType		 */		 		public static function getDescription(o:*):XML {			return describeType( getType( o ) );		}		/**		 * Return the classes the class extends.		 */		public static function getSuperClasses(o:*):Array {			var superClasses:Array = new Array( );			var superclassQualifiedNames:XMLList = getDescription( o ).factory.extendsClass.@type;			for each( var className:XML in superclassQualifiedNames ) {				superClasses.push( getDefinitionByName( className ) );			}			return superClasses;		}				/**		 * Return the interfaces the class implements.		 */		public static function getInterfaces(o:*):Array {			var interfaces:Array = new Array( );			var interfaceQualifiedNames:XMLList = getDescription( o ).factory.implementsInterface.@type;			for each( var interfaceName:XML in interfaceQualifiedNames ) {				interfaces.push( getDefinitionByName( interfaceName ) );			}			return interfaces;		}		/**		 * Is the class marked as final		 */		public static function isFinal(o:*):Boolean {			return getDescription( o ).@isFinal == 'true' ? true : false;		}		/**		 * Is the class marked as dynamic		 * <p>note: flash.utils.describeType lies to us and only returns the correct answer 		 * if you use describeType on an instance of a class, not the class itself.</p>		 */		public static function isDynamic(o:*):Boolean {			return getDescription( o ).@isDynamic == 'true' ? true : false;			}		/**		 * Is this a class or an interface?		 */		public static function isConcrete(o:*):Boolean {			return ( getDescription( o ).factory[0].extendsClass.length( ) > 0 ) ? true : false;		}		/**		 * Is this class an interface?		 */		public static function isInterface(o:*):Boolean {			return ( getDescription( o ).factory[0].extendsClass.length( ) == 0 ) ? true : false;		}		/**		 * Indicates if the reflected class is a subclass of the supplied class		 */		public static function isSubClassOf( subClass:*, superClass:Class ):Boolean {				return getSuperClasses( subClass ).indexOf( superClass ) > -1 ? true : false;		}		/**		 * Indicates if the reflected class implements the supplied type		 */		public static function isImplementorOf( subInterface:Class, superInterface:Class ):Boolean {			if( getType( subInterface ) === subInterface ) return true;			return ( isSubClassOf( subInterface, superInterface ) );		}			}}